Title : Writeup for Project 3,Spring 2012
Date: 03/25/12
Group Num 3:  
Name                     Email                   StudentID
Shengzhe Chen     shengzhc@usc.edu       	4341396265
Pei Chu           peichu@usc.edu            	4097373598

I.Requirements:

1. For part1 and part2, implement the virtual memory with TLB and memory management. It is essential that we do not have enough physical main memory to load the sources, so we have to store the source on disk where in Nachos is a file. And when the source is referred, we should find them and load them into nachos's physical memory to run.
2. For part3, implement the lock, condition and monitor variable system calls for client and the interaction between client and server. These RPCs and packets are encoded in our specific communication protocol.

II.Assumptions:

1. Nachos's physical main memory get back to 32 pages.
2. TLB has 4 entries.
3. You are able to switch between FIFO and RANDOM methods to apply different swapping out approach. Besides, the default swapping method is RANDOM page evicting. 
4. When implementing network part, we use the -DUSE_TLB to turn on the TLB so that the user program will run with TLB.
5. Make an assumption of the interaction between server and client. The interactive data is using in the below way. The first byte is the command, the hardcode defined request and reply value. For each request and reply, the client and server will acquire the function of each field in the corresponding data.
6. The protocol is defined in protocol.h in network directory.
7. When run in network, the server only allows at most 256(which defined in sersynch.h) client locks, conditions and mvs for client, and we assume its amount is sufficient so that we eliminate the destroy process, just replying the destroy reply back when destroy lock and condition. Besides, each lock, condition and mv has its own name within in its scope. It means, name is the ID for lock, condition and mv, respectively. While creating them, it should return the index if it has already existed, or return the index after allocating a new one.
8. As for the server lock which used in network sys calls, the lock owner we use is a integer value, which is identical. It is generated by the machine id * 100 + mail box id. 
9. For part3, server is fixed with machine id 0, client id should be different among clients. 
10. For part3, each client is a single process with a single thread, which means if using fork or exec to do something relevant to request server, it might happen to error receiving.
11. Each client only has one mailbox, and the mailbox 0 is the default sending and receiving terminator. 
12. Swap file has its default name "swapfile", so that each client might share the same swapfile. In this case, we might have to limit the size of user program so that it will not write something to swapfile, although it exists. 
13. While sending a Request the server, each system call should connect to the server first, making sure the server connectable. 

III.Design:

Part I & II
1. Data
In this part, we have to manage the main memory and swap file, so we need to implement the entry for ipt and swap. The entries are represented as IPTTranslationEntry and SwapTranslationEntry. Besides, in order to well organize the ipt and swap buffer, We implement the ipt class and swap class to seal the behavior of them. 
2. Logic
the process flow in this part should be worked among tlb, ipt, and swap. When a page is modified, the dirty bit will be set in tlb, so that when happens to a p.f.e, we should
update the dirty bits in ipt, and do the following things. When a p.f.e occurs, it will check whether the page is in ipt. If it is not in ipt, we should load the source from swap file or executable file. When a page is dirty, it should be loaded from swap file any time after the first time it is evicted to swap file, because a dirty page could never be rewritten back to executable file. When the instructions or data loaded into memory, the next thing to do is to modify the tab, making sure that the same command will match the tlb, and retrieve the data just loaded.

Part III
1. Data
In this part, we should implement the interaction between server and client. First, it is quite important to formulate the protocol between server and client. Client sends the request and receive the reply, while Server receives the request and send the reply. Each packet contains two kinds of header and a fixed size mail data. We use the first byte to stand for the command, the other bytes serves as values passing between server and client. 
Besides, We enclose the data and headers within a message class. In addition, two classes, client and server, are imported to enclose the operations of client and server. In this part, lock, condition, and mv are different from the previous project, we also need new version of these classes, they are defined in sersynch.h.
2. Logic
Actually, in part3, the client and server are interacted through some files. We use the postoffice class provided to receive and send the msg, it is quite easy to import this class into our new classes to fulfill the function. What we have to do is to make sure the  communication regulation. One sends, one receives. Note that the condition's wait, signal and broadcast are quite different from the previous version. Here we should suspend the reply message until some moment. For example, wait reply message should be suspend until the signal occurs, while the signal's appearance should not send the wait reply msg because the wait reply should be send after the lock acquire. It is a little difficult to depict, but it should be noticed when dealing with condition's operations.

IV.Implementation:

+Files Modified

exception.cc   addrspace.cc   addrspace.h   progtest.cc   syscall.h   main.cc  scheduler.cc  scheduler.h  system.cc  system.h

+Files added
network directory: client.cc   client.h   message.cc   message.h   server.cc   server.h   sersynch.cc  sersynch.h   protocol.h    
Test direcroty: p1.c   p2.c   p3.c   p4.c   p5.c   part1_test.c   part2_test.c  
                       test1_c1.c   test1_c2.c   test1_c3.c  test2_c1.c    test2_c2.c    
                       test3_c1.c   test3_c2.c   test3_c3.c   test3_c4.c
userprog directory: ipt.cc   ipt.h   swap.cc   swap.h   server.cc    client.cc

+Data Structure added

sersynch.h:
class SLock {
    public:
    SLock(char *name);
    ~SLock();
    int Acquire(int presentowner);
    int Release(int presentowner);
    void Pend(Message *msg);
    Message *GetMsg();
    void SetOwner(int own) {owner = own;}
     char *GetName() {return lockname;}
 private:
    char *lockname;
    List *waitingList;
    int owner;
    bool status;
};

class SLockTable {
 public:
    SLockTable();
    ~SLockTable();
    SLock *GetLock(int index);
    int Acquire(int lockid);
    void Pend(int lockid, Message *msg);
    int Acquire(int lockid, int owner);
    int Release(int lockid, int owner);
    Message *GetMsg(int lockid);
    int SearchName(char *name);
    int AssignLock(char *name);
    int Destroy(int lockid);
    void SetLockOwner(int lockid, int owner);
private:
    BitMap *slmap;
    SLock **sltable;
};

class SCondition {
public:
    SCondition(char *name);
    ~SCondition();
    char *GetName() {return scname;}
    void Pend(Message *msg);
    int Wait(int lockid);
    int Signal(int lockid);
    Message* GetMsg();
private:
    char *scname;
    List *waitingList;
    SLock *waitingLock;
};

class SCTable {
 public:
    SCTable();
    ~SCTable();
    Message* GetMsg(int cvid);
    void Pend(int cvid, Message *msg);
    int SearchName(char *name);
    int AssignCondition(char *name);
    int Destroy(int cvid);
    int Wait(int cvid, int lockid);
    int Signal(int cvid, int lockid);
private:
    BitMap *scmap;
    SCondition **sctable;
};

class MV
{
public:
    MV(char *name, int size) {mvname = name; length = size; mv = new int[size];}
    ~MV() {delete mvname; delete mv;}
    char *GetName() {return mvname;}
    int SetValue(int index, int value);
    int GetValue(int index);
private:
    char *mvname;
    int *mv;
    int length;
};

class MVTable {
public:
    MVTable();
    ~MVTable();
    int SearchName(char *name);
    int AssignMV(char *name, int size);
    int SetMV(int mvid, int index, int value);
    int GetMV(int mvid, int index);
    int DestroyMV(int mvid);
private:
    BitMap *mvmap;
    MV **mvtable;
};

+Data Structure modified

nothing

+Functions added

client.cc:
    Client::Client(NetworkAddress addr, double reliability, int nBoxes, int box);
    Client::~Client();
    bool Connect(NetworkAddress addr, int box);
    void DisConnect();
    void Send(char *);
    void Receive(char **);
    void Print();

message.cc:
    Message::Message(PacketHeader phdr, MailHeader mhdr, char *buffer);
    Message::~Message();

post.cc:
   PostOffice::PostOffice(NetworkAddress addr, double reliability, int nBoxes);
   PostOffice::~PostOffice();		    
    bool Send(PacketHeader pktHdr, MailHeader mailHdr, char *data);
    				
    void Receive(int box, PacketHeader *pktHdr, MailHeader *mailHdr, char *data);
    void PostalDelivery();	
    void PacketSent();		
    void IncomingPacket();

server.cc:
   Server::Server(NetworkAddress addr, double reliability, int nBoxes, int box);
   Server:: ~Server();
    void Run();
    void Reply(Message *msg);
    void Print();
    void ConnectReply(PacketHeader outPktHdr, MailHeader outMailHdr);
    void CreateLockReply(PacketHeader outPktHdr, MailHeader outMailHdr, char *data);
    void DestroyLockReply(int lockid, PacketHeader outPktHdr, MailHeader outMailHdr);
    void AcquireLockReply(int lockid, PacketHeader outPktHdr, MailHeader outMailHdr);
    void ReleaseLockReply(int lockid, PacketHeader outPktHdr, MailHeader outMailHdr);
    void CreateConditionReply(PacketHeader outPktHdr, MailHeader outMailHdr, char *in);
    void DestroyConditionReply(int cvid, PacketHeader outPktHdr, MailHeader outMailHdr);
    void WaitConditionReply(int cvid, int lockid, PacketHeader outPktHdr, MailHeader outMailHdr);
    void SignalConditionReply(int cvid, int lockid, PacketHeader outPktHdr, MailHeader outMailHdr);
    void BroadcastConditionReply(int cvid, int lockid, PacketHeader outPktHdr, MailHeader outMailHdr);
    void CreateMVReply(PacketHeader outPktHdr, MailHeader outMailHdr, char *in);
    void SetMVReply(int mvid, int index, int value, PacketHeader outPktHdr, MailHeader outMailHdr);
    void GetMVReply(int mvid, int index, PacketHeader outPktHdr, MailHeader outMailHdr);
    void DestroyMVReply(int mvid, PacketHeader outPktHdr, MailHeader outMailHdr);	

sersynch.cc:
   MVTable::MVTable();
    MVTable::~MVTable();
    int SearchName(char *name);
    int AssignMV(char *name, int size);
    int SetMV(int mvid, int index, int value);
    int GetMV(int mvid, int index);
    int DestroyMV(int mvid);

   MV::MV(char *name, int size) {mvname = name; length = size; mv = new int[size];}
    MV::~MV() {delete mvname; delete mv;}
    char *GetName() {return mvname;}
    int SetValue(int index, int value);
    int GetValue(int index);
 
  SCTable::SCTable();
    SCTable::~SCTable();
    Message* GetMsg(int cvid);
    void Pend(int cvid, Message *msg);
    int SearchName(char *name);
    int AssignCondition(char *name);
    int Destroy(int cvid);
    int Wait(int cvid, int lockid);
    int Signal(int cvid, int lockid);

  SCondition::SCondition(char *name);
   SCondition:: ~SCondition();
    char *GetName() {return scname;}
    void Pend(Message *msg);
    int Wait(int lockid);
    int Signal(int lockid);
    Message* GetMsg();
   
   SLockTable::SLockTable();
    SLockTable::~SLockTable();
    SLock *GetLock(int index);
    int Acquire(int lockid);
    void Pend(int lockid, Message *msg);
    int Acquire(int lockid, int owner);
    int Release(int lockid, int owner);
    Message *GetMsg(int lockid);
    int SearchName(char *name);
    int AssignLock(char *name);
    int Destroy(int lockid);
    void SetLockOwner(int lockid, int owner);

    SLock::SLock(char *name);
    SLock::~SLock();
    int Acquire(int presentowner);
    int Release(int presentowner);
    void Pend(Message *msg);
    Message *GetMsg();
    void SetOwner(int own) {owner = own;}

TranslationEntry *AddrSpace::SearchEntry(int vaddr)   --------addrspace.cc
void TerminateProcess()    -----------addrspace.cc
int CreateMV_Syscall(unsigned int vaddr, int length, int size);  ---addrspace.cc
int SetMV_Syscall(int mvid, int index, int value);      -----addrspace.cc
int GetMV_Syscall(int mvid, int index);      -------addrspace.cc
int DestroyMV_Syscall(int mvid);     -------addrspace.cc

int Scheduler::ReadyCount();    ---------scheduler.cc

+Functions modified

addrspace.cc:

int AddrSpace::AllocateNewStack() ; 
int AddrSpace::DeallocateStack() ;
int CreateLock_Syscall(unsigned int vaddr, int length) ;
int DestroyLock_Syscall(int lockid);
int AcquireLock_Syscall(int lockid);
int ReleaseLock_Syscall(int lockid);
int CreateCondition_Syscall(unsigned int vaddr, int length);
int DestroyCondition_Syscall(int cvid);
int WaitCondition_Syscall(int cvid, int lockid);
int SignalCondition_Syscall(int cvid, int lockid);
int BroadcastCondition_Syscall(int cvid, int lockid);
void Exit_Syscall(int status);
int Exec_Syscall(unsigned int vaddr, int length); 
void ExceptionHandler(ExceptionType which) ;

StartProcess(char *filename)  -------progtest.cc
int main(int argc, char **argv) -------main.cc
void Initialize(int argc, char **argv) ----system.cc
void Cleanup(); ----system.cc

V.Testing:
1.part1_test

For part1_test,user should use the command "nachos -P {FIFO|RAND} -x ../test/part1_test" within vm directory.
The -P option is for choosing method of replacing entry in main memory and user can test them respectively.
The output will print the lock and condition use information of different thread and as well test the console input function and user level error.  
Besides, user can use the existing "matmult"  for additional part1_test by the command "nachos -P {FIFO|RAND} -x ../test/matmult" within vm directory.
Note:If you don't use the -P option,the default method is RAND.

2.part2_test

For part2_test, user should use the command "nachos -p {FIFO|RAND} -x ../test/part2_test" within vm directory.
The -P option is also for choosing method of replacing entry in main memory and user can test them respectively.
The output will print the Exec and Fork sys call information of different process and thread and test the error of User Mode.

Note:Through  part1_test and part2_test, we could prove that the right implementation of lock and condition mechanism and the correct use of virtual memory.Because we can run different processes and threads using one or more address space without corrupting each other.When you use the -rs, the sequence may be different,but for each subtest the sequence is trackable.

3.part3_test
For part3_test,there are several test scenarios as follows:
(For each scenario,user should first use the command "nachos -P {FIFO|RAND}" within network directory to run the server.)

a.Test1 is for testing lock mechanism.

To test lock mechanism,user should open another terminal and use the command "nachos -P {FIFO|RAND} -x ../test/test1_c1 -m <#machine>" within network directory.The <#machine> should be a certain small integer,such as 1,2,3 and so on,but not 0(0 is for the server).
The test1_c1 is for negative test of lock,condition and MV, so the output will be "copy error" and cannot continue, which situation should be stopped by "control+z".

To test acquire and release lock correctly and illegally,user should use the command "nachos -P {FIFO|RAND} -x ../test/test1_c2 -m <#machine>" and "nachos -P {FIFO|RAND} -x ../test/test1_c3 -m <#machine>" respectively just from the former "client terminal".The output will display the lock use information both from the server terminal and client terminal.

b.Test2 is for testing condition wait and signal.

To test  the condition mechanism,user should open two client terminals.For one client,use command "nachos -P {FIFO|RAND} -x ../test/test2_c1 -m <#machine>" while for the other,use "nachos -P {FIFO|RAND} -x ../test/test2_c2 -m <#machine> ".The #machine should be different of these two client terminals. The client1 terminal is waiting for client2 to signal.Thus, after running test2_c2,the output will appear on the client1,client2 and server terminal to show the condition information.

c.Test3 is for broadcasting condition variable.

First,user should open four client terminals and use the command as bellows:
For the first three terminal,type "nachos -P {FIFO|RAND} -x ../test/test3_c1 -m <#machine>","nachos -P {FIFO|RAND} -x ../test/test3_c2 -m <#machine>" and "nachos -P {FIFO|RAND} -x ../test/test3_c3 -m <#machine>" respectively.Then the first three clients are waiting for the fourth client to broadcast.For the fourth terminal,use command "nachos -P {FIFO|RAND} -x ../test/test3_c4 -m <#machine>". The corresponding information will be shown on these four clients terminal and the server terminal.

VI.Discussion:

+Experiment expectation
For part1, first we expect to pass the value 7220 to exit sys call through matmult to prove that the virtual memory is working correctly.Then, by multiprocess and multithread, we expect to see that they can work independently and don't corrupt each other.
For part2,we should implement the FIFO and RAND method correctly,which can be observed through the -P command option and the main memory use situation of multiprocess or multithread.Explicitly,the expectation is the right use information from the part2_test.
For part3,we expect the server is always running and the client terminals could use lock,condition mechanism correctly.
Besides,for all the three parts,we also expect to see desirable fault mechanism of the invalid use or user level error, such as the negative index of a lock and so on.

+Experiment Result

Just as same as the experiment expectation.

+Explanation

The part1_test and part2_test together prove the correctness of virtual memory implementation and the FIFO/RAND moving routine.Because through the -P option we use the FIFO/RAND routine and through the output information, we can see whether the virtual memory is implemented right.The test for part3 is to prove whether the client can send and receive message through the server correctly.Thus, we design three type tests and use several client terminals to see whether they can communicate expectedly.

VII.Miscellaneous:

1. Here we are not explicitly using destroyxxx system calls. When using such system calls, it will delete the corresponding object in server. So we do not implement the strategy to keep them, but the quantity is enough for allocating server lock, condition and mv.
2. For part3, the user program is not using exec and fork, because we only have 1 mail box so that each thread that will send request to server might receive msg chaotically. In this case, the client is one process, one thread.
3. Server has the reply to "test" and "server close", but we do not import them in the test cases, we assume that server will not terminate forever.

