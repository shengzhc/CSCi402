#ifndef Nachos_sersynch_h
#define Nachos_sersynch_h

#include "post.h"
#include "synch.h"
#include "list.h"
#include "server.h"
#include "message.h"
#include "bitmap.h"

#define SL_MAX 256
#define SC_MAX 256
#define MV_MAX 256

// Define the server side lock that accepts the client request
class SLock {
        
public:
    SLock(char *name);
    ~SLock();
    int Acquire(int presentowner);
    int Release(int presentowner);
    void Pend(Message *msg);
    Message *GetMsg();
    void SetOwner(int own) {owner = own;}
    
public:
    char *GetName() {return lockname;}
    
private:
    char *lockname; 
    List *waitingList;
    int owner; // owner is generated by machine id*100+mail box id
    bool status;
};
// Define the serverlock table that manages the serverlock
class SLockTable {
    
public:
    SLockTable();
    ~SLockTable();
    SLock *GetLock(int index);
    int Acquire(int lockid);
    void Pend(int lockid, Message *msg);
    int Acquire(int lockid, int owner);
    int Release(int lockid, int owner);
    Message *GetMsg(int lockid);
    int SearchName(char *name);
    int AssignLock(char *name);
    int Destroy(int lockid);
    void SetLockOwner(int lockid, int owner);

    
private:
    BitMap *slmap; // use the manage the busy/free indicator of the lock table
    SLock **sltable;

};
// Define the server side condition that accepts the client request
class SCondition {
    
public:
    SCondition(char *name);
    ~SCondition();
    char *GetName() {return scname;}
    void Pend(Message *msg);
    int Wait(int lockid);
    int Signal(int lockid);
    Message* GetMsg();
private:
    char *scname;
    List *waitingList;
    SLock *waitingLock; 
};
// Define the server condition table that manages the server conditions
class SCTable {
    
public:
    SCTable();
    ~SCTable();
    Message* GetMsg(int cvid);
    void Pend(int cvid, Message *msg);
    int SearchName(char *name);
    int AssignCondition(char *name);
    int Destroy(int cvid);
    int Wait(int cvid, int lockid);
    int Signal(int cvid, int lockid);
private:
    BitMap *scmap;
    SCondition **sctable;
};
// Define the server monitor variable that accepts the client request
class MV {
public:
    MV(char *name, int size) {mvname = name; length = size; mv = new int[size];}
    ~MV() {delete mvname; delete mv;}
    char *GetName() {return mvname;}
    int SetValue(int index, int value);
    int GetValue(int index);
private:
    char *mvname;
    int *mv;
    int length; // use the bound the size of a monitor variable
};
// Define the server mv table that manages the server mv
class MVTable {
public:
    MVTable();
    ~MVTable();
    int SearchName(char *name);
    int AssignMV(char *name, int size);
    int SetMV(int mvid, int index, int value);
    int GetMV(int mvid, int index);
    int DestroyMV(int mvid);

private:
    BitMap *mvmap;
    MV **mvtable;
};

#endif
